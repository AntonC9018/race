using System;
using System.Reflection;
using System.Xml.Serialization;
using TMPro;
using UnityEngine;
using UnityEngine.Events;
using UnityEngine.UI;
using static EngineCommon.Assertions;

namespace Race.Garage
{
    /// <summary>
    /// Contains the name of the given stat, just as it should be diplayed in the UI.
    /// </summary>
    // TODO: generate code with this attribute, currently unimplemented.
    public class DisplayNameAttribute : InspectorNameAttribute
    {
        public DisplayNameAttribute(string displayName) : base(displayName)
        {
        }
    }

    /// <summary>
    /// Stored in CarDataModel, <see cref="EngineCommon.CarProperties"/>  
    /// </summary>
    [System.Serializable]
    public struct CarStats
    {
        /// <summary>
        /// The amount of overload a car can take, essentially.
        /// Driving in a wrong gear damages the car. 
        /// </summary>
        [Range(1, 100)]
        public float health;
        
        /// <summary>
        /// </summary>
        [DisplayName("speed")]
        [Range(0.1f, 2)]
        public float accelerationModifier;
    }

    /// <summary>
    /// I thought it might be worth it to put this data into a separate struct.
    /// </summary>
    [System.Serializable]
    public struct CarStatsInfo
    {
        /// <summary>
        /// Base, unchangeable stats of the car.
        /// The values cannot go below these values and are purely additive on top.
        /// </summary>
        // TODO: May be worth it to store this field as a reference type.
        public CarStats baseStats;

        /// <summary>
        /// The total value of base stats + additional stat value.
        /// </summary>
        // [System.NonSerialized]
        [XmlIgnore]
        public float totalStatValue;

        /// <summary>
        /// This value can be redistributed among the stats to increase them.
        /// Represents the max such value.
        /// </summary>
        public float additionalStatValue;
        
        /// <summary>
        /// The current stat values.
        /// </summary>
        public CarStats currentStats;

        /// <summary>
        /// We could initialize these properties (in my case fields) lazily, but
        /// there isn't much benefit in that. The only benefit is that this function won't have to
        /// be called after the struct is initialized.
        /// </summary>
        public void ComputeNonSerializedProperties()
        {
            var baseValue = baseStats.GetTotalValue();
            totalStatValue = baseValue + additionalStatValue;
        }
    }

    public static class CarStatsHelper
    {
        // TODO: should be autogenerated.
        internal static CarStatFieldReflectionInfo[] _StatReflectionInfos;

        public const int Count = 2;
        public const int HealthIndex = 0;
        public const int AccelerationModifierIndex = 1;

        // A manual meaningless switch works for now, but code generation is way better here.
        // Doing this manually is way too fragile.
        public static ref float GetStatRef(this ref CarStats stats, int index)
        {
            switch (index)
            {
                case HealthIndex:
                    return ref stats.health;
                case AccelerationModifierIndex:
                    return ref stats.accelerationModifier;
                default:
                {
                    assert(false);
                    // A dummy return here.
                    return ref stats.health;
                }
            }
        }

        static CarStatsHelper()
        {
            var type = typeof(CarStats);
            // This one allocates a new array, which we don't really need.
            var fields = type.GetFields();
            assert(fields.Length == CarStatsHelper.Count);
            _StatReflectionInfos = new CarStatFieldReflectionInfo[CarStatsHelper.Count];
            for (int i = 0; i < CarStatsHelper.Count; i++)
            {
                var field = fields[i];
                ref var currentInfo = ref _StatReflectionInfos[i];
                
                {
                    var rangeAttribute = field.GetCustomAttribute<RangeAttribute>();
                    assert(rangeAttribute is not null, field.Name);
                    currentInfo.minValue = rangeAttribute.min;
                    currentInfo.maxValue = rangeAttribute.max;
                }

                {
                    var nameAttribute = field.GetCustomAttribute<DisplayNameAttribute>();
                    if (nameAttribute is null)
                    {
                        // TODO: capitalize appropriately.
                        currentInfo.displayName = field.Name;
                    }
                    else
                    {
                        currentInfo.displayName = nameAttribute.displayName;
                    }
                }
            }
        }

        public static float GetTotalValue(this ref CarStats stats)
        {
            float sum = 0;
            // TODO: autogenerate this sum (without a switch).
            for (int i = 0; i < Count; i++)
                sum += stats.GetStatRef(i) / _StatReflectionInfos[i].ValueRange;
            return sum;
        }
    }

    public struct CarStatFieldReflectionInfo
    {
        /// <summary>
        /// The string displayed to the user.
        /// </summary>
        // TODO: localization.
        public string displayName;
        public float minValue;
        public float maxValue;
        public float ValueRange => maxValue - minValue;
    }

    public class CarStatsManager : MonoBehaviour
    {
        // IMPORTANT: This object is assumed to be pristine, unmodified by other things,
        // such that it only contains the game objects added by this class.
        [SerializeField] private RectTransform _statsTransform;

        /// <summary>
        /// Children must have a slider component and a label component.
        /// </summary>
        [SerializeField] private GameObject _statsSliderPrefab;

        // Maybe use a singleton?
        [SerializeField] private CarProperties _carProperties;

        // This one might not be needed at all, because we can just
        // hide or destory the children and be done with it.
        private ValueChangedCapture[] _sliderValueChangedCaptures;

        // May want to store the cached sliders, depends on performance we get.
        private Slider[] _sliders;

        void Start()
        {
            assert(_carProperties != null);
            assert(_statsTransform != null);
            assert(_statsSliderPrefab != null);
            assert(_statsTransform.childCount == 0,
                "The layout object must be empty and must be unmodified by other code");

            {
                // I'm not sure how to do this one correctly.
                // _statsTransform.gameObject.SetActive(false);

                // I'm not sure how this works with the immediate children adding children locally.
                // layoutTransform.hierarchyCapacity = CarStats.Count;

                _sliderValueChangedCaptures = new ValueChangedCapture[CarStatsHelper.Count];
                
                _sliders = new Slider[CarStatsHelper.Count];

                for (int i = 0; i < CarStatsHelper.Count; i++)
                {
                    var childGameObject = GameObject.Instantiate(_statsSliderPrefab);
                    ref var info = ref CarStatsHelper._StatReflectionInfos[i];
                    childGameObject.name = info.displayName;
                    
                    {
                        var slider = childGameObject.GetComponentInChildren<Slider>();
                        assert(slider != null);
                        slider.minValue = info.minValue;
                        slider.maxValue = info.maxValue;
                        slider.value = slider.minValue;

                        // TODO: none of this nonsense. should be autogenerated.
                        var capture = new ValueChangedCapture(this, i);
                        slider.onValueChanged.AddListener(capture.Delegate);
                        _sliderValueChangedCaptures[i] = capture;

                        _sliders[i] = slider;
                    }
                    {
                        // This might mess up things, because it does depth first search,
                        // but really we want breadth first search here.
                        var label = childGameObject.GetComponentInChildren<TMP_Text>();
                        assert(label != null);
                        label.text = info.displayName;
                    }

                    childGameObject.transform.SetParent(_statsTransform, worldPositionStays: false);
                }
             
                _statsTransform.gameObject.SetActive(true);
            }
        }

        void OnEnable()
        {
            assert(_statsTransform != null);
            _statsTransform.gameObject.SetActive(true);

            // TODO: might be worth it to serialize these.
            _carProperties.OnCarSelected.AddListener(OnCarSelected);
        }
        
        void OnDisable()
        {
            if (_statsTransform == null)
                return;
            _statsTransform.gameObject.SetActive(false);

            // TODO: it's not clear whether we want this yet.
            #if false
            {
                var childCount = layoutTransform.childCount;

                assert(childCount == _sliderValueChangedDelegates.Length,
                    "The layout object must be empty and must be unmodified by other code");

                for (int i = 0; i < childCount; i++)
                {
                    var childTransform = _statsLayout.GetChild(i);
                    var slider = childTransform.GetComponentInChildren<Slider>();
                    assert(slider != null);
                    // TODO: make sure it's been removed.
                    slider.onValueChanged.RemoveListener(_sliderValueChangedCaptures[i].Delegate);
                }
            }
            #endif

            for (int i = 0; i < CarStatsHelper.Count; i++)
            {
                _sliders[i].onValueChanged.RemoveListener(_sliderValueChangedCaptures[i].Delegate);
            }

            _carProperties.OnCarSelected.RemoveListener(OnCarSelected);
        }

        public class ValueChangedCapture
        {
            private CarStatsManager _statsManager;
            private int _sliderIndex;

            public ValueChangedCapture(CarStatsManager statsManager, int sliderIndex)
            {
                _statsManager = statsManager;
                _sliderIndex = sliderIndex;
            }

            public void Delegate(float value)
            {
                _statsManager.OnSliderValueChanged(_sliderIndex, value);
            }
        }

        private void OnSliderValueChanged(int sliderIndex, float value)
        {
            if (!_carProperties.IsAnyCarSelected)
                return;

            assert(sliderIndex < CarStatsHelper.Count);

            ref var info = ref _carProperties.CurrentCarInfo.dataModel.statsInfo;
            ref var currentStats = ref info.currentStats;
            ref float stat = ref currentStats.GetStatRef(sliderIndex);
            if (Mathf.Approximately(value, stat))
                return;

            float baseValue = info.baseStats.GetStatRef(sliderIndex);
            float newValue = value;
            // It's already clamped from above, so we only clamp it from below.
            if (newValue < baseValue)
                newValue = baseValue;
            stat = newValue;

            // Floats lose precision.
            // This is why I recalculate it every time by summing up the stats.
            // And subtracting that from the total allowed "stat value".
            // It may be worth it to always store the underlying values as ints.
            // Or maybe at least store them within the same range, and then rescale
            // them when they are needed.
            // TODO: maybe cache this sum, although it really doens't matter.
            float totalCurrentValue = currentStats.GetTotalValue();
            float overflow = totalCurrentValue - info.totalStatValue;
            if (overflow > 0)
            {
                newValue -= overflow * CarStatsHelper._StatReflectionInfos[sliderIndex].ValueRange;
            }

            assert(Mathf.Approximately(newValue, baseValue)
                || newValue > baseValue);

            if (!Mathf.Approximately(value, newValue))
                _sliders[sliderIndex].value = newValue;

            // Old idea: scrapped. Redistribution happens manually.
            // float removedValue = (value - stat) / _statReflectionInfos[sliderIndex].ValueRange;
            // float valuePerStatToAdd = removedValue / (CarStatsHelper.Count - 1);
            // for (int i = 0; i < CarStatsHelper.Count; i++)
            // {
            //     if (i != sliderIndex)
            //     {
            //         // Obvious bug: this is unconstrained by the max value.
            //         float addedValue = valuePerStatToAdd * _statReflectionInfos[i].ValueRange;
            //         ref float v = ref stats.GetStatRef(i);
            //         v += addedValue;
            //         _sliders[i].value = v;
            //     }
            // }

            // TODO: might want to keep the old stats too, so, perhaps, have a setter for the stats.
            _carProperties.TriggerStatsChangedEvent(sliderIndex);
        }

        private void OnCarSelected(CarSelectionChangedEventInfo info)
        {
            assert(info.previousIndex != info.currentIndex);

            // Might want to disable the canvas component, people say it's more efficient.
            if (info.previousIndex == -1)
            {
                _statsTransform.gameObject.SetActive(true);
            }
            else if (info.currentIndex == -1)
            {
                // This line makes it so that the slider go away when no car is selected.
                // _statsTransform.gameObject.SetActive(false);
                return;
            }

            // Should be equivalent to _carProperties.CurrentCarInfo.
            // TODO: tests for these events.
            ref var statsInfo = ref info.CurrentCarInfo.dataModel.statsInfo;
            
            // Reset stats
            {
                // Since we know these don't change, might be worth it to cache them.
                var sliders = _statsTransform.GetComponentsInChildren<Slider>();
                assert(sliders.Length == CarStatsHelper.Count);

                for (int i = 0; i < CarStatsHelper.Count; i++)
                {
                    // Since the stats are set, this won't trigger the redistribution in our own callback.
                    sliders[i].value = statsInfo.currentStats.GetStatRef(i);
                }
            }

            _carProperties.TriggerStatsChangedEvent();
        }
    }

    
    // Reflection without boxing of the struct with __makeref.
    // https://stackoverflow.com/a/9928322/9731532
    // The problem here is that the value still has to be boxed, so there's little benefit.
    static class ReflectionHelper
    {
        public static void SetValueForValueType<T>(this FieldInfo field, ref T item, object value) where T : struct
        {
            field.SetValueDirect(__makeref(item), value);
        }
    }
}