using System;
using System.Reflection;
using UnityEngine;
using UnityEngine.Events;
using UnityEngine.UI;
using static EngineCommon.Assertions;

namespace Race.Garage
{
    /// <summary>
    /// Contains the name of the given stat, just as it should be diplayed in the UI.
    /// </summary>
    // TODO: generate code with this attribute, currently unimplemented.
    public class DisplayNameAttribute : InspectorNameAttribute
    {
        public DisplayNameAttribute(string displayName) : base(displayName)
        {
        }
    }

    /// <summary>
    /// Stored in CarDataModel, <see cref="EngineCommon.CarProperties"/>  
    /// </summary>
    [System.Serializable]
    public struct CarStats
    {
        /// <summary>
        /// The amount of overload a car can take, essentially.
        /// Driving in a wrong gear damages the car. 
        /// </summary>
        [Range(1, 100)]
        public float health;
        
        /// <summary>
        /// </summary>
        [DisplayName("speed")]
        [Range(0.1f, 2)]
        public float accelerationModifier;
    }

    public static class CarStatsHelper
    {
        public const int Count = 2;
        public const int HealthIndex = 0;
        public const int AccelerationModifierIndex = 1;

        // A manual meaningless switch works for now, but code generation is way better here.
        // Doing this manually is way too fragile.
        public static ref float GetStatRef(this ref CarStats stats, int index)
        {
            switch (index)
            {
                case HealthIndex:
                    return ref stats.health;
                case AccelerationModifierIndex:
                    return ref stats.accelerationModifier;
                default:
                {
                    assert(false);
                    // A dummy return here.
                    return ref stats.health;
                }
            }
        }
    }

    public struct CarStatFieldReflectionInfo
    {
        /// <summary>
        /// The string displayed to the user.
        /// </summary>
        // TODO: localization.
        public string displayName;
        public float minValue;
        public float maxValue;
        public float ValueRange => maxValue - minValue;
    }
    
    public class CarStatsManager : MonoBehaviour
    {
        // For now, do this manually, but I would like to generate code for this.
        // IMPORTANT: This object is assumed to be pristine, unmodified by other things,
        // such that it only contains the game objects added by this class,
        [SerializeField] private RectTransform _statsTransform;

        /// <summary>
        /// Children must have a slider component and a label component.
        /// </summary>
        [SerializeField] private GameObject _statsSliderPrefab;

        // Maybe use a singleton?
        [SerializeField] private CarProperties _carProperties;

        // TODO: should be autogenerated.
        private CarStatFieldReflectionInfo[] _statReflectionInfos;
        // This one might not be needed at all, because we can just
        // hide or destory the children and be done with it.
        private UnityAction<float>[] _sliderValueChangedDelegates;

        // May want to store the cached sliders, depends on performance we get.
        // private Slider[] _sliders;

        void Setup()
        {
            assert(_carProperties != null);
            assert(_statsTransform != null);
            assert(_statsSliderPrefab != null);
            assert(_statsTransform.childCount == 0,
                "The layout object must be empty and must be unmodified by other code");

            {
                var type = typeof(CarStats);
                // This one allocates a new array, which we don't really need.
                var fields = type.GetFields();
                assert(fields.Length == CarStatsHelper.Count);
                _statReflectionInfos = new CarStatFieldReflectionInfo[CarStatsHelper.Count];
                for (int i = 0; i < CarStatsHelper.Count; i++)
                {
                    var field = fields[i];
                    ref var currentInfo = ref _statReflectionInfos[i];
                    
                    {
                        var rangeAttribute = field.GetCustomAttribute<RangeAttribute>();
                        assert(rangeAttribute is not null, field.Name);
                        currentInfo.minValue = rangeAttribute.min;
                        currentInfo.maxValue = rangeAttribute.max;
                    }

                    {
                        var nameAttribute = field.GetCustomAttribute<DisplayNameAttribute>();
                        if (nameAttribute is null)
                        {
                            // TODO: capitalize appropriately.
                            currentInfo.displayName = field.Name;
                        }
                        else
                        {
                            currentInfo.displayName = nameAttribute.displayName;
                        }
                    }
                }
            }

            {
                // I'm not sure how to do this one correctly.
                // _statsTransform.gameObject.SetActive(false);

                // I'm not sure how this works with the immediate children adding children locally.
                // layoutTransform.hierarchyCapacity = CarStats.Count;

                _sliderValueChangedDelegates = new UnityAction<float>[CarStatsHelper.Count];
                
                // _sliders = new Slider[CarStats.Count];

                for (int i = 0; i < CarStatsHelper.Count; i++)
                {
                    var parentGameObject = GameObject.Instantiate(_statsSliderPrefab);
                    ref var info = ref _statReflectionInfos[i];
                    parentGameObject.name = info.displayName;
                    
                    {
                        var slider = parentGameObject.GetComponentInChildren<Slider>();
                        assert(slider != null);
                        slider.minValue = info.minValue;
                        slider.maxValue = info.maxValue;
                        slider.value = slider.minValue;

                        // TODO: none of this nonsense. should be autogenerated.
                        UnityAction<float> deleg = (float a) => OnSliderValueChanged(i, a);
                        slider.onValueChanged.AddListener(deleg);
                        _sliderValueChangedDelegates[i] = deleg;

                        // _sliders[i] = slider;
                    }
                    {
                        // This might mess up things, because it does depth first search,
                        // but really we want breadth first search here.
                        var label = parentGameObject.GetComponentInChildren<Text>();
                        assert(label != null);
                        label.text = info.displayName;
                    }

                    parentGameObject.transform.SetParent(_statsTransform, worldPositionStays: false);
                }
             
                _statsTransform.gameObject.SetActive(true);
            }
        }

        void OnEnable()
        {
            assert(_statsTransform != null);
            _statsTransform.gameObject.SetActive(true);
        }
        
        void OnDisable()
        {
            if (_statsTransform == null)
                return;
            _statsTransform.gameObject.SetActive(false);

            // TODO: it's not clear whether we want this yet.
            #if false
            {
                var childCount = layoutTransform.childCount;

                assert(childCount == _sliderValueChangedDelegates.Length,
                    "The layout object must be empty and must be unmodified by other code");

                for (int i = 0; i < childCount; i++)
                {
                    var childTransform = _statsLayout.GetChild(i);
                    var slider = childTransform.GetComponentInChildren<Slider>();
                    assert(slider != null);
                    // TODO: make sure it's been removed.
                    slider.onValueChanged.RemoveListener(_sliderValueChangedDelegates[i]);
                }
            }
            #endif
        }

        private void OnSliderValueChanged(int sliderIndex, float value)
        {
            if (!_carProperties.IsAnyCarSelected)
                return;

            assert(sliderIndex > _statReflectionInfos.Length);

            ref var stats = ref _carProperties.CurrentCarInfo.DataModel.stats;
            ref float stat = ref stats.GetStatRef(sliderIndex);
            float removedValue = (value - stat) / _statReflectionInfos[sliderIndex].ValueRange;
            if (Mathf.Approximately(removedValue, 0))
                return;
            
            stat = value;

            float valuePerStatToAdd = removedValue / (_statReflectionInfos.Length - 1);
            for (int i = 0; i < _statReflectionInfos.Length; i++)
            {
                if (i != sliderIndex)
                {
                    // Obvious bug: this is unconstrained by the max value.
                    float addedValue = valuePerStatToAdd * _statReflectionInfos[i].ValueRange;
                    stats.GetStatRef(i) = addedValue;
                }
            }

            // TODO: might want to keep the old stats too, so, perhaps, have a setter for the stats.
            _carProperties.TriggerAllStatsChangedEvent();
        }

        private void OnCarSelected(int previousCarIndex, int currentCarIndex)
        {
            assert(previousCarIndex != currentCarIndex);

            // Might want to disable the canvas component, people say it's more efficient.
            if (previousCarIndex == -1)
            {
                _statsTransform.gameObject.SetActive(true);
            }
            else if (currentCarIndex == -1)
            {
                _statsTransform.gameObject.SetActive(false);
                return;
            }

            // Should be equivalent to _carProperties.CurrentCarInfo.
            // TODO: tests for these events.
            ref var stats = ref _carProperties.GetCarInfo(currentCarIndex).DataModel.stats;
            
            // Reset stats
            {
                // Since we know these don't change, might be worth it to cache them.
                var sliders = _statsTransform.GetComponentsInChildren<Slider>();
                assert(sliders.Length == CarStatsHelper.Count);

                for (int i = 0; i < CarStatsHelper.Count; i++)
                {
                    // Since the stats are set, this won't trigger the redistribution in our own callback.
                    sliders[i].value = stats.GetStatRef(i);
                }
            }
        }
    }

    
    // Reflection without boxing of the struct with __makeref.
    // https://stackoverflow.com/a/9928322/9731532
    // The problem here is that the value still has to be boxed, so there's little benefit.
    static class ReflectionHelper
    {
        public static void SetValueForValueType<T>(this FieldInfo field, ref T item, object value) where T : struct
        {
            field.SetValueDirect(__makeref(item), value);
        }
    }
}